<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RSA on p1um&#39;s blog</title>
    <link>https://p1um3r.github.io/series/rsa/</link>
    <description>Recent content in RSA on p1um&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Jul 2023 08:00:00 +0800</lastBuildDate><atom:link href="https://p1um3r.github.io/series/rsa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RSA解题总结</title>
      <link>https://p1um3r.github.io/blog/rsa%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 11 Jul 2023 08:00:00 +0800</pubDate>
      
      <guid>https://p1um3r.github.io/blog/rsa%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h1 id=&#34;rsa解题总结&#34;&gt;RSA解题总结&lt;/h1&gt;
&lt;h2 id=&#34;一般情况&#34;&gt;一般情况&lt;/h2&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;
&lt;h3 id=&#34;解密&#34;&gt;解密&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p = 1325465431
q = 152317153
e = 65537
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; libnum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; q
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;phi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (q &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(e, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, phi)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(c, d, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(libnum&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;n2s(int(m)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.PublicKey &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; RSA
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Cipher &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; PKCS1_OAEP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gmpy2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; binascii
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;phi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (q &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(e, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, phi)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rsa_components &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (n, e, int(d), p, q)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;arsa &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RSA&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;construct(rsa_components)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rsakey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RSA&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;importKey(arsa&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;exportKey())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rsakey &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PKCS1_OAEP&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(rsakey)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;decrypted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rsakey&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(c)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(decrypted)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 用于加密时经过填充，导致c和n长度一样的情况，此时用pow解会出现乱码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;共模数攻击&#34;&gt;共模数攻击&lt;/h2&gt;
&lt;h3 id=&#34;攻击流程&#34;&gt;攻击流程&lt;/h3&gt;
&lt;p&gt;1.攻击者获得两个或多个$RSA$公钥，它们共用相同的模数$n$。&lt;/p&gt;
&lt;p&gt;2.攻击者选取一个消息$m$，并对其进行加密，得到密文$c_1=m^{e_1} \bmod n$和$c_2=m^{e_2} \bmod n$，其中$e_1$和$e_2$分别是两个公钥中的指数&lt;/p&gt;
&lt;p&gt;3.攻击者寻找模数$n$和两个指数$e_1$和$e_2$的最大公约数$\gcd(e_1,e_2)$，并将其命名为$g$。&lt;/p&gt;
&lt;p&gt;4.如果$g$不等于 1，则说明攻击者找到了至少一个质因数$p$或$q$,并可以用它来推导$RSA$私钥中的指数$d$。&lt;/p&gt;
&lt;p&gt;5.通过继续计算，攻击者可以确定私钥中的指数$d$，并从而获得原始消息$m$。&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; gmpy2 &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gcdext
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; libnum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xa6241c28743fbbe4f2f67cee7121497f622fd81947af30f327fb028445b39c2d517ba7fdcb5f6ac9e6217205f8ec9576bdec7a0faef221c29291c784eed393cd95eb0d358d2a1a35dbff05d6fa0cc597f672dcfbeecbb14bd1462cb6ba4f465f30f22e595c36e6282c3e426831d30f0479ee18b870ab658a54571774d25d6875&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x3045&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xff4d&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x5d1e39bc751108ec0a1397d79e63c013d238915d13380ae649e84d7d85ebcffbbc35ebb18d2218ccbc5409290dfa8a4847e5923c3420e83b1a9d7aa67190dc0d34711cce261665c64c28ed2834394d4b181926febf7eb685f9ce81f36c7fb72798da3a14a123287171d26e084948aab0fba81c53f10b5696fc291006254ee690&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x3d90f2bec4fe02d8ce4cece3ddb6baed99337f7e6856eef255445741b5cfe378390f058679d70236e51be4746db4c207f274c40b092e24f8c155a0957867e84dca48e27980af488d2615a280c6eadec2f1d30b95653b1ee3135e2edff100dd2c529994f846722f811348b082d0bec7cfab579a4bd0ab789928b1bebed68d628f&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;g, r, s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gcdext(e1, e2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(c1, r, n) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pow(c2, s, n) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(libnum&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;n2s(int(m)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;低加密指数广播攻击&#34;&gt;低加密指数广播攻击&lt;/h2&gt;
&lt;h3 id=&#34;适用情况&#34;&gt;适用情况&lt;/h3&gt;
&lt;p&gt;e很小，并且使用了相同的加密指数e给若干个接收者发送相同的信息&lt;/p&gt;
&lt;p&gt;例如当$e=3$时，有以下等式成立：
$$
c_1 = pow(m,e,n_1)\newline
c_2 = pow(m,e,n_2)\newline
c_3 = pow(m,e,n_3)\newline
&amp;hellip;
$$
对上列等式运用中国剩余定理，得到
$$
c_x = pow(m,e,n_1*n_2*n_3*\cdots)
$$
随后再进行低加密指数攻击。&lt;/p&gt;
&lt;h3 id=&#34;实现-1&#34;&gt;实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gmpy2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; functools &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; reduce
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CRT&lt;/span&gt;(clist, nlist):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reduce(&lt;span style=&#34;color:#66d9ef&#34;&gt;lambda&lt;/span&gt; x, y: x &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; y, nlist)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c, n &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(clist, nlist):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d, r, s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;gcdext(n, m)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Exception&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Input not pairwise co-prime&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; N, N
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;142782424368849674771976671955176187834932417027468006479038058385550042422280158726561712259205616626939123504489410624745195777853423961104590708231562726165590769610040722589287393102301338152085670464005026301781192671834390892019478189768725018303217559795377795540494239283891894830166363576205812991157&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;153610425077816156109768509904751446801233412970601397035720458311275245730833227428213917577405780162151444202393431444812010569489900435979730559895340377469612234558042643742219128033827948585534761030527275423811282367831985007507137144308704413007806012914286105842311420933479771294576841956749281552971&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;152540067782701001222493009941492423063369171831039847414320547494725020441901272486665728360741395415762864872737675660423920609681185809510355937534756399208661762715484879562585724584849261266873624875852300611683382543315580370484972470694466195837255994159609193239840228218925381488410059939975556977947&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;125842716702134814646356078531900645012495638692517778270527426844383063904041812273637776798591687732598509470005151551320457132061693618473039437320011446697406190781306264437609046721508738109650829547010385875425097336266103994639126319889016342284747700714199556143378526590058467791687837422897022829661&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;116144389285266462769913139639175922392318396923181100785008570884082681963637784423143843845816350379438789947802939701820129805341796427821894273985551331666719808355412080909245720551238149511778060242720419584504473490216670437024863860559347959698828131475160058721701582089480924088773887932997353631767&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;127833907448946785858374094953899556339175475846831397383049660262333005992005484987913355932559627279178940862787593749842796469355336182379062826441222705075178971785791223706944120681105575965622931327112817747065200324610697178273898956820957640413744954233327851461318200323486469677469950386824833536523&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;130561613227079478921314550968562766645507834694262831586725464124109153306162445639759476845681271537955934718244296904503168256991962908095007040044300188572466395275317838178325500238288302672390013747102961340256309124310478931896245221622317302428447389760864327859640573452084295225059466376349115703119&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;115953389401040751013569404909249958538962411171147823610874077094621794755967854844224923689925397631692572916641171075740839099217316101334941033937183815345038898177087515909675028366437302462022970987947264115373697445950951595479758872029099661065186221250394358255523574834723958546450323357472451930993&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;143437107845384843564651522639125300763388830136500260725097766445883003928355325003575359566631064630487365774344508496878731109174874449170057678821440711511966073934025028100604234445470976333825866939923998344367645612128590820812489407412175198698290167077116185959180877334222693344630253253476594907313&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;85033868418784308573673709960700777350314426427677627319697346811123742342359072170220428874952996988431950989321281905284522596263957356289624365171732095210045916218066135140320107686084053271623461104022705353814233772164502775939590711842361956121603943483040254727995655776263673058788416722141673409688&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;66065963470666895005407449599703926269325406456711861190876894466341571726360462706664546294453572319565476664348345756905411939632955966517708138047546806602828064213238537646393524578984547577761559965654539771172357089802682793169968961304179886652390277814477825753096636750388350662980872556701402397564&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;116011740820520887443111656288411611070614127688662643257265381793048354928820176624229624692124188995846076431510548507016903260774215950803926107831505634778278712070141663189086436127990584944132764896694777031370995058271038329228336417590284517922855284619653301817355115583540545182119702335431334401666&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;97640420284096094887471273365295984332267897927392169402918423863919914002451127544715668846623138003564829254309568918651163254043205129883843425179687841236818720463784828905460885026290909768599562386370732119591181513319548915478512030197629196018254041500662654260834562708620760373487652389789200792120&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8112507653841374573057048967617108909055624101437903775740427861003476480616929517639719198652146909660899632120639789106782550275648578142883715280547602249589837441805676364041484345030575130408744621981440093280624046635769338568542048839419939250444929802135605724150484414516536378791500915047844188300&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;36792148360808115566234645242678223867680969786675055638670907933041180936164293809961667801099516457636164692292891528415720085345494773373966277807505798679784807614784581861287048096977968620964436947452527540958289441390882589051225367658014709290392321808926567572528170531844664734909469690750971883323&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;53043093283305492238903255767698153246673671181809989362223466090875767705978690531154079519999671834688647277179370374802495005937892824566602423646978168777735383632928274082669949750078161820002768640908750005814934158829006019656592134357897586040866207754535586785064545866404380204728594863102313407789&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;88499407133762624445946519155722583633934260410706930537441122463087556094734626189377091740335667052378955691250910459790202385799502439716173363179773811920751410726795431402796346647688144853156900427797933862087074385441977254140336390678022955770879265490567987868532251217565094093318626424653599450992&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;138337520305048557335599940473834485492131424901034295018189264168040969172072024612859307499682986987325414798210700710891033749119834960687318156171051379643844580970963540418974136891389303624057726575516576726845229494107327508855516437230240365759885913142671816868762838801720492804671259709458388192984&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x, n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT(c, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m, flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;iroot(x, e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; flag:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;m=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;m&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;could not decode m&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;素数分解&#34;&gt;素数分解&lt;/h2&gt;
&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;
&lt;p&gt;1、n值为&lt;strong&gt;临近&lt;/strong&gt;素数相乘得到可用yafu分解&lt;/p&gt;
&lt;h2 id=&#34;低加密指数攻击&#34;&gt;低加密指数攻击&lt;/h2&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;在 RSA 中 e 也称为加密指数。&lt;/p&gt;
&lt;p&gt;由于 e 是可以随意选取的，选取小一点的 e 可以缩短加密时间，但是选取不当的话，就会造成安全问题。&lt;/p&gt;
&lt;p&gt;若$m^3 &amp;lt; n$，即$c = m^3$&lt;/p&gt;
&lt;p&gt;若$m^3 &amp;gt; n$但并非$m^3 \gg n$，即$c = (m^3 + i * n) \bmod n$，其中$i$是我们需要爆破的系数&lt;/p&gt;
&lt;h3 id=&#34;实现-2&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;若$m^3 &amp;lt; n$&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gmpy2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22885480907469109159947272333565375109310485067211461543881386718201442106967914852474989176175269612229966461160065872310916096148216253429849921988412342732706875998100337754561586600637594798877898552625378551427864501926224989873772743227733285336042475675299391051376624685754547818835551263597996620383338263448888107691240136257201191331617560711786674975909597833383395574686942099700631002290836152972352041024137872983284691831292216787307841877839674258086005814225532597955826353796634417780156185485054141684249037538570742860026295194559710972266059844824388916869414355952432189722465103299013237588737&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15685364647213619014219110070569189770745535885901269792039052046431067708991036961644224230125219358149236447900927116989931929305133870392430610563331490276096858863490412102016758082433435355613099047001069687409209484751075897343335693872741&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m, flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;iroot(c, e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; flag:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;m=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;m&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;could not decode m&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若$m^3&amp;gt;n$但并非$m^3\gg n$&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gmpy2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;114976915747243387792157708464120735018971336213935438953074748276198282761939060395482051056351068439137722626185590043024556656813730840050547350912425438364703854627760482842307943026011880815011654341047422453012558617703411700393668892701036222135444420377515575624398723436532681305293727164639582093389&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5828813410620741112500628876643872258919868379601617907887884191584237969605489971465692568848339200057188383649365078832766143513766368216471491824042974016773526107276856706832404477882581400769791378958901067683158857990261489285951805740071223765359992165262854641069674603160977034446644199945940251030&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m, flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;iroot(c &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n, e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; flag:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;m=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;m&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;低解密指数攻击-wiener-attack&#34;&gt;低解密指数攻击 (Wiener Attack)&lt;/h2&gt;
&lt;h3 id=&#34;实现-3&#34;&gt;实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gmpy2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Util.number &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; long_to_bytes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;transform&lt;/span&gt;(x, y):  &lt;span style=&#34;color:#75715e&#34;&gt;# 使用辗转相处将分数 x/y 转为连分数的形式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; y:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(x&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;y)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        x, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; y, x &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; y
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;continued_fraction&lt;/span&gt;(sub_res):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    numerator, denominator &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; sub_res[::&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]:  &lt;span style=&#34;color:#75715e&#34;&gt;# 从sublist的后面往前循环&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        denominator, numerator &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; numerator, i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;numerator&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;denominator
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; denominator, numerator  &lt;span style=&#34;color:#75715e&#34;&gt;# 得到渐进分数的分母和分子，并返回&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 求解每个渐进分数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sub_fraction&lt;/span&gt;(x, y):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; transform(x, y)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 将连分数的结果逐一截取以求渐进分数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(continued_fraction, (res[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:i] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(res)))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_pq&lt;/span&gt;(a, b, c):  &lt;span style=&#34;color:#75715e&#34;&gt;# 由p+q和pq的值通过维达定理来求解p和q&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    par &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;isqrt(b&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;c)  &lt;span style=&#34;color:#75715e&#34;&gt;# 由上述可得，开根号一定是整数，因为有解&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x1, x2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;par)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a), (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;par)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x1, x2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wienerAttack&lt;/span&gt;(e, n):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (d, k) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; sub_fraction(e, n):  &lt;span style=&#34;color:#75715e&#34;&gt;# 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# 可能会出现连分数的第一个为0的情况，排除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (e&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;d&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:  &lt;span style=&#34;color:#75715e&#34;&gt;# ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        phi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (e&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;d&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;k  &lt;span style=&#34;color:#75715e&#34;&gt;# 这个结果就是 φ(n)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        px, qy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_pq(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;phi&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; px&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;qy &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            p, q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; abs(int(px)), abs(int(qy))  &lt;span style=&#34;color:#75715e&#34;&gt;# 可能会得到两个负数，负负得正未尝不会出现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;invert(e, (p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(q&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;该方法不适用&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; wienerAttack(e, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(c, d, n)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;p---1光滑数分解&#34;&gt;$p - 1$光滑数分解&lt;/h2&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;前置知识&lt;/h3&gt;
&lt;p&gt;费马小定理$(Fermat Theorem)$：若$p$是素数，且$p \nmid a$,则$a^{p-1} \equiv 1(\bmod p)$&lt;/p&gt;
&lt;p&gt;​                 $//$本来是$a^p \equiv a(\bmod p)$，为了方便我们写成上面的形式&lt;/p&gt;
&lt;p&gt;$B-Smooth$数：如果一个整数的所有素因子都不大于B，我们称这个整数为$B-Smooth$数。&lt;/p&gt;
&lt;p&gt;例$1:12=2&lt;em&gt;2&lt;/em&gt;3$，因此$12$是$3-Smooth$的数&lt;/p&gt;
&lt;p&gt;例$2:30=2&lt;em&gt;3&lt;/em&gt;5$，因此$130$是$5-Smooth$的数&lt;/p&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;光滑数 (Smooth number)：指可以分解为小素数乘积的正整数&lt;/p&gt;
&lt;p&gt;当p是N 的因数，并且p−1是光滑数，可以考虑使用&lt;code&gt;Pollard&#39;s p-1&lt;/code&gt;算法来分解N&lt;/p&gt;
&lt;p&gt;当p是N的因数，并且p+1是光滑数，可以考虑使用&lt;code&gt;Williams&#39;s p+1&lt;/code&gt;算法来分解N&lt;/p&gt;
&lt;h3 id=&#34;原理-1&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;设$p-1$是$B-Smooth$的，可设$p-1=p_1p_2&amp;hellip;p_n(\forall 1\le i\le n,p_i\le B)$&lt;/p&gt;
&lt;p&gt;若$p_1,p_2,&amp;hellip;,p_n$两两不同，则$p_1p_2&amp;hellip;p_n\mid B! \Rightarrow (p-1)\mid B!\Rightarrow B!=k(p-1)$。因此$a^{B!} \equiv a^{k(p-1)}\equiv 1(\bmod p)$&lt;/p&gt;
&lt;p&gt;假设$N=pq$，计算$\gcd(a^{B!}-1, N)$，只要结果大于$0$小于$N$，那么结果就为$p$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/8f6e63a2fa13494a81e0f65c2ccf1c9d.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;实现-4&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;P &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prod(primes)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 这里的2是任取的&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, P, n) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gcd(pp, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; int(p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; q &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;phi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (q &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inverse_mod(e, phi)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(c, d, n)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from gmpy2 import *
a = 2
n = 2
while True:
    a = pow(a, n, N)
    res = gcd(a-1, N)
    if res != 1 and res != N:
        q = N // res
        print(&amp;#34;p=&amp;#34;,res)
        print(&amp;#34;q=&amp;#34;,q)
        break
    n += 1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;p1光滑数分解&#34;&gt;$p+1$光滑数分解&lt;/h2&gt;
&lt;h2 id=&#34;dp泄露&#34;&gt;$dp$泄露&lt;/h2&gt;
&lt;h3 id=&#34;实现-5&#34;&gt;实现&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gmpy2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; libnum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;65537&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, e &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dp &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; e &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (((dp &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; e &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; i) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ((dp &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; e &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; i) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; (((dp &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; e &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; i) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        phi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (q &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gmpy2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;invert(e, phi)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(pow(c, d, n))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(libnum&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;n2s(m))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;common-prime-rsa&#34;&gt;Common Prime RSA&lt;/h2&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;
&lt;p&gt;Wiener 提出，如果 $p$ 和 $q$ 是素数，使得 $p-1$ 和 $q-1$ 有一个大数因子，那么具有这种性质的素数可以作为 Wiener Attack 的反制措施。&lt;/p&gt;
&lt;p&gt;根据这种理论，出现了一种 $p-1$ 和 $q-1$ 拥有一个共同的大素数因子的 RSA 变体，我们称作共素数RSA（Common Prime RSA）。&lt;/p&gt;
&lt;p&gt;对于某个大素数 $g$，让 $p=2ga+1$ 且 $q=2gb+1$ 作为平衡素数，保证 $a,b$ 互素且 $h=2gab+a+b$ 是素数。第一个限制确保 $\gcd(p-1,q-1)=2g$，第二个限制确保 $(pq-1)/2=gh$ 与 $N=pq$ 的大小接近。&lt;/p&gt;
&lt;p&gt;因为由上述算法生成的素数 $p,q$ 满足 $g=\gcd(p-1,q-1)$ 是一个大素数因子，故称 $p,q$ 为共素数（common primes）。其中 $g$ 为这两个素数的共因子（common factor）。&lt;/p&gt;
&lt;p&gt;我们需要注意到对于共素数RSA有着以下性质：
$$
\lambda(pq)=\mathrm{lcm}(p-1,q-1)=\mathrm{lcm}(2ga,2gb)=2gab\
\varphi(pq)=(p-1)(q-1)=2ga2gb=2g\lambda(pq)
$$
此外存在额外定义，RSA加密指数和解密指数需要与 $\lambda(pq)$ 互素。&lt;/p&gt;
&lt;p&gt;根据上述定义，可以推导出
$$
N=pq=(2ga+1)(2gb+1)=2g(2gab+a+b)+1=2gh+1
$$
即 $N-1$ 为
$$
N-1=2g(2gab+a+b)=2gh
$$
定义 $\gamma$ 表示共因子 $g$ 的相对于 $N$ 的大小，即 $g=N^\gamma$。考虑 $g\leq N^{1/2}$，故 $0\leq\gamma\leq1/2$。&lt;/p&gt;
&lt;h3 id=&#34;生成算法&#34;&gt;生成算法&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Util.number &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    gcd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NameError&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; math &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gcd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gen_prime&lt;/span&gt;(nbits: int, gamma: float):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getPrime(int(nbits &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; gamma))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    alpha &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; gamma
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getRandomNBitInteger(int(alpha &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nbits))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; isPrime(p):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getRandomNBitInteger(int(alpha &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nbits))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; isPrime(q) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; isPrime(h) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; gcd(a, b) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getRandomNBitInteger(int(alpha &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; nbits))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; p, q
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(gen_prime(&lt;span style=&#34;color:#ae81ff&#34;&gt;512&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.48&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;攻击&#34;&gt;攻击&lt;/h3&gt;
&lt;h4 id=&#34;gamma-接近于-12&#34;&gt;$\gamma$ 接近于 $1/2$&lt;/h4&gt;
&lt;p&gt;当 $\gamma$ 接近于 $1/2$ 时，$g=N^\gamma$ 接近于 $N^{1/2}$，由于共素数RSA的特殊构造我们可以在 $O(N^{1/4-\gamma/2})$ 分解 $N$，故此时算法时间复杂度接近于 $O(1)$。&lt;/p&gt;
&lt;p&gt;此时我们只需修改 &lt;code&gt;Pollard&#39;s rho method&lt;/code&gt; 的 $x_i$ 函数。&lt;/p&gt;
&lt;p&gt;在 Mckee&amp;amp;Pinch 的论文&lt;a href=&#34;https://citeseerx.ist.psu.edu/doc_view/pid/64294c404088b69a519614510b8d12b4809a6b10&#34;&gt;《Further Attacks on Server-Aided RSA Cryptosystems》&lt;/a&gt;中指出将 $f(x)=x^2+1$ 修改为 $f(x)=x^{N-1}+3\pmod{N}$ 是最优解。&lt;/p&gt;
&lt;p&gt;由于 $N-1=2gh$ 且 $p-1=2ga$，故最多只有一个值不在 $x^{N-1}\mod{p}$ 的环中。&lt;/p&gt;
&lt;p&gt;算法实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    gcd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NameError&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; math &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; gcd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rho&lt;/span&gt;(N):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;lambda&lt;/span&gt; x: (pow(x, N&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, N) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; N
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 加快入环速度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, N)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f(t)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        step_times &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        step_limit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; step_times &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; step_limit:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                step_times &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                step_limit &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f(h)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gcd(abs(int(t) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; int(h)), N)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; N:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (p, N &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f(h)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                step_times &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(rho(&lt;span style=&#34;color:#ae81ff&#34;&gt;84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;故事实证明 $\gamma$ 值的选取不能过于接近 $1/2$。&lt;/p&gt;
&lt;h4 id=&#34;已知-ab&#34;&gt;已知 $a,b$&lt;/h4&gt;
&lt;p&gt;已知 $N=2g(2gab+a+b)+1$，于是我们构造方程
$$
4abg^2+2(a+b)g-N+1=0
$$
可以在多项式时间 $\log(N)$ 内分解 $N$。&lt;/p&gt;
&lt;p&gt;Sagemath 代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1185431345934512&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1989628969125971&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;54692260436051338814890781701826055707958209029414126894070449935683071253184867947357262267840171428710181955973010913204514025135188192484651672240708141692701667242130748316666406528479191422804307020656050201187035928715833163999813216597718706449260040885862566373392398826670863398295350419792842640631&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;P&lt;span style=&#34;color:#f92672&#34;&gt;.&amp;lt;&lt;/span&gt;g&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ZZ[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;roots()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; g:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; g[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; q &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; N
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Python 可以借助 &lt;code&gt;sympy&lt;/code&gt; 解方程。&lt;/p&gt;
&lt;h4 id=&#34;已知-g&#34;&gt;已知 $g$&lt;/h4&gt;
&lt;p&gt;当 $g\geq a+b$ 时，会导致在多项式时间为 $\log(N)$ 内分解 $N$，同时因为素数是平衡的，条件相当于 $g&amp;gt;N^{1/4}$。&lt;/p&gt;
&lt;p&gt;证明如下：&lt;/p&gt;
&lt;p&gt;我们假设 $g&amp;gt;a+b$，那么给予 $N,g$，令 $M=(N-1)/(2g)$，$c=a+b$，那么方程
$$
N=2g(2gab+a+b)+1
$$
可以改写成
$$
M=2gab+c
$$
因为 $c=a+b&amp;lt;g$，根据假设，可以归约为模 $g$ 域下的方程：
$$
c=M\pmod{g}
$$
因此，$c=a+b$ 是已知的。&lt;/p&gt;
&lt;p&gt;将 $b=c-a$ 带回方程 $N=2g(2gab+a+b)+1$，整理可得二次方程：
$$
2ga^2-2gca+(N-1)/(2g)-c=0
$$
可以解得 $a,b$ 为该方程两解。&lt;/p&gt;
&lt;p&gt;假设 $g=a+b$，我们将方程 $N=2g(2gab+a+b)+1$ 作等价替换，整理得到方程
$$
\frac{N-1}{4g^2}=ab+\frac{1}{2}
$$
我们再进一步替换 $b=g-a$，再次整理可得二次方程：
$$
a^2-ga+\frac{N-1}{4g^2}-\frac{1}{2}=0
$$
可以解得 $a,b$。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;$g&amp;gt;a+b$ 时，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2056971706333850947354991471886113601423457483931388832864204860321308350537317091564919029078296379733989138742162694786565228112885684303&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;67324909911911622626246005558967775211455024820506932698435813321567574468019013664789401988015894964099052816176029553245881317276340043887466584645914352982274378611180595397686920214079479901514703963131435008906250160656759300390805929849374653321934393399433471228218819498373221757779799476717494079667&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;M &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; M &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; g
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;P&lt;span style=&#34;color:#f92672&#34;&gt;.&amp;lt;&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ZZ[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; M &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;roots()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], a[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; q &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; N
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;$g=a+b$ 时，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2855372645569408464444580237486670388029956719716115953907612135874419892154982850222965560661211729647325085879529571229774148545656169021&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;159549169988238873893531105042878385551537587717347282632324748268846735710748763722602882823022008548774298858161130258369850715542192739582830583643642436399008902770027668038725347353393047833875066622910131525247842517372845617227325882916166114361718015983671803859502931814932543107911548450229250776542101141849788751722460468073974316977656001286989710480324512919121409123619799426221232443036698458643438020098037548757403&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;M &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;P&lt;span style=&#34;color:#f92672&#34;&gt;.&amp;lt;&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ZZ[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;roots()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], a[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; q &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; N
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为 $p=2ga+1$，注意到 $g&amp;gt;N^{1/4}$ 是已知的，故我们也可以用 &lt;code&gt;Coppersmith&#39;s factoring&lt;/code&gt; 方法分解模数。&lt;/p&gt;
&lt;p&gt;而当 $g&amp;lt;a+b$ 时，我们可以使用时间复杂度为 $O(N^{1/4-\gamma})$ 的算法分解 $N$，每个操作的多项式时间为 $\log(N)$。&lt;/p&gt;
&lt;p&gt;证明如下：&lt;/p&gt;
&lt;p&gt;已知 $g$，我们可以通过除法算法计算 $u$ 和 $0\leq v\leq2g$，例如：
$$
\frac{N-1}{2g}=2gu+v
$$
因为我们知道 $N=2g(2gab+a+b)+1$，于是乎
$$
a+b=v+2gc\
ab=u-c
$$
其中 $c$ 为任意整数。&lt;/p&gt;
&lt;p&gt;对于任意与 $N$ 互素的整数 $x$，我们有
$$
x^{u2g}\equiv x^{ab2g+c2g}\equiv x^{c2g}\pmod{N}
$$
因为 $u=ab+c$ 且 $\lambda(N)=2gab$，所以 $x^{2gab}\equiv 1\pmod{N}$。&lt;/p&gt;
&lt;p&gt;让 $y=x^{2g}$，我们有
$$
y^u\equiv y^c\pmod{N}
$$
根据这个关系，未知的 $c$ 可以用 Shanks 的小步大步法（baby-step giant-step methodology）求解。对于某些 $d&amp;gt;\sqrt{c}$，我们计算得到大步为
$$
y^0,y^d,y^{2d},\cdots,y^{d^2}\mod{N}
$$
小步为
$$
y^u,y^{u-1},y^{u-2},\cdots,y^{u-d}\mod{N}
$$
在其中搜索碰撞，将会产生一个 $r$ 和 $s$ 满足：
$$
y^{rd}\equiv y^{u-s}\pmod{N}
$$
其中 $c=rd+s$。&lt;/p&gt;
&lt;p&gt;当 $c$ 已知，我们可以计算 $a,b$。&lt;/p&gt;
&lt;p&gt;计算，排序和搜索需要 $O(d\log(d))$ 操作，其中 $d&amp;gt;\sqrt{c}$。&lt;/p&gt;
&lt;p&gt;故使用这种算法需求 $\gamma$ 接近于 $1/4$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本人多次跑这个算法，最终验证可得 $c$ 的大致范围大概率会落在 $N^{(1/2-2\gamma)}$ 的附近，取上下浮动两位大小最佳。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sagemath 如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; sage.groups.generic &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bsgs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;g &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;28838314918840273611038952856252141148393903858815521699377328440901497&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;23895816238623712091906549349650291003358466897973970818205381234024572750472476312894286233088847723906345049342176974080465940396626170377635736786780099297743807402105462746828310247313063710700453371777283064626446124365885063073122303271609231832129823571694756234973129694217982548355078107610764879363&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nbits &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gamma &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.23&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cbits &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ceil(nbits &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; gamma))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;M &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; M &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; M &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; u
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GF &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Zmod(N)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GF&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;random_element()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# c的范围大概与N^(0.5-2*gamma)很接近&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bsgs(y, y &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; u, (int(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;(cbits&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)), int(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;(cbits&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ab &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;P&lt;span style=&#34;color:#f92672&#34;&gt;.&amp;lt;&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ZZ[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; apb &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ab
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;roots()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; a:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], a[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; q &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; N
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;分解-n-1&#34;&gt;分解 $N-1$&lt;/h4&gt;
&lt;p&gt;当 $\gamma$ 过小，即 $g=N^\gamma$ 过小时，因为已知 $N-1=2gh$，故分解出 $g$ 是较为容易的。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;yafu&lt;/code&gt; 分解 $\frac{N-1}{2}$，其中当 $\gamma$ 值约为 0.10 左右时分解迅速。&lt;/p&gt;
&lt;h2 id=&#34;coppersmith定理攻击&#34;&gt;coppersmith定理攻击&lt;/h2&gt;
&lt;h3 id=&#34;基本原理&#34;&gt;基本原理&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>RSA学习笔记（1）</title>
      <link>https://p1um3r.github.io/blog/rsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Tue, 18 Apr 2023 08:00:00 +0800</pubDate>
      
      <guid>https://p1um3r.github.io/blog/rsa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid>
      <description>&lt;h1 id=&#34;rsa学习笔记1&#34;&gt;RSA学习笔记（1）&lt;/h1&gt;
&lt;p&gt;（参考：cryptanalysis of RSA and its variants)&lt;/p&gt;
&lt;h2 id=&#34;一rsa算法系统&#34;&gt;一、RSA算法系统&lt;/h2&gt;
&lt;h3 id=&#34;11-公钥密码学&#34;&gt;1.1 公钥密码学&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;公钥密码学的概念最早是在20世纪70年代中期由Diffie、Hellman和Merkle提出的。基于Stinson对于密码学的定义，我们对公钥密码系统使用了以下几个定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、$\mathcal{P}$是有限个可能的明文的集合&lt;/p&gt;
&lt;p&gt;2、$\mathcal{C}$ 是有限个可能的密文的集合&lt;/p&gt;
&lt;p&gt;3、$\mathcal{K}$ 是有限个可能的密钥的集合，$\mathcal{K}$  被称作密钥空间&lt;/p&gt;
&lt;p&gt;4、&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于密钥空间中的任意一个密钥$K\in \mathcal{K}$，总存在一个加密方法
$$
enc_K：\mathcal{P} \to \mathcal{C}
$$
和一个解密方法
$$
dec_K:\mathcal{C}\to\mathcal{P}
$$
使得对于每个$m\in\mathcal{P}$，总有
$$
dec_K(enc_K(m))=m
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5、对于任意密钥$K\in\mathcal{K}$ 和明文$m\in \mathcal{P}$，都很容易计算出$enc_K(m)$ 和$dec_K(enc_K(m))$&lt;/p&gt;
&lt;p&gt;6、对于几乎所有的密钥$K\in \mathcal{K}$，每一个易于计算的$dec_K$，都几乎不可能从$enc_K$中得出，也就是说，如果没有$dec_K$就很难进行解密。&lt;/p&gt;
&lt;p&gt;7、加密规则$enc_K$是公有的，解密规则$dec_K$是保密的。&lt;/p&gt;
&lt;p&gt;或者，我们可以把公钥密码学分为三个部分：&lt;strong&gt;密钥生成算法&lt;/strong&gt;、&lt;strong&gt;加密算法&lt;/strong&gt;和&lt;strong&gt;解密算法&lt;/strong&gt;。其中，我们用密钥生成算法定义密钥空间$\mathcal{K}$，用加密算法和解密算法定义明文空间 $\mathcal{P}$ 和密文空间 $\mathcal{C}$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://assets.cdn.prod.twilio.com/original_images/19DfiKodi3T25Xz7g9EDTyvF9di2SzvJo6JebRJaCN-1P_c1fMqGtrAyZzxGGucG0bcmR8UwNes-gS&#34; alt=&#34;What is Public Key Cryptography?&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-rsa密码系统&#34;&gt;1.2 RSA密码系统&lt;/h3&gt;
&lt;h4 id=&#34;121-rsa密码系统的结构&#34;&gt;1.2.1 RSA密码系统的结构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RSA密码系统是已知的公开的第一个公钥密码系统。&lt;/p&gt;
&lt;p&gt;1977年，Gardner在《科学美国人》的一篇文章中介绍了这个密码系统，一年后，RSA密码系统的发明者罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）共同发布了完整的研究论文。RSA就是他们三人姓氏开头字母拼在一起组成的。&lt;/p&gt;
&lt;p&gt;由于作者们都在麻省理工工作，这个密码系统最初被称作MIT公钥密码系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy93QWtBSUZzMTFxYXhTbkpBZ3FpY2ppYXZTMU5BNll0ZndWYk9pY3ZwMW9iM1hvbERFVm9YQ2xNNEFZRTh2MlprSWljUjgxNkd5OWdTVFByT1VGOTZxY0tpY0VnLzY0MA?x-oss-process=image/format,png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据上述对公钥密码系统的定义，我们可以给出RSA最初的的版本，也叫做textbook RSA&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;RSA密码系统&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、令$N=pq$，其中，$p$和$q$为两个大素数&lt;/p&gt;
&lt;p&gt;2、令$\mathcal{P}=\mathcal{C}=\mathbb{Z}_N$(模N后的整数)&lt;/p&gt;
&lt;p&gt;3、将密钥空间定义为
$$
\mathcal{K}={(N,p,q,e,d):ed\equiv1(\mod\phi(N))}
$$
其中$\phi(N)$是欧拉函数，$\phi(N)=(p-1)(q-1)$&lt;/p&gt;
&lt;p&gt;4、对于每个密钥$K\in \mathcal{K}$，因为$K=(N,p,q,e,d)$，加密方法$enc_K:\mathbb{Z}_N\to{\mathbb{Z}_N}$可以定义为
$$
enc_K(x)=x^e\mod(N)
$$
5、解密方法$dec_K:\mathbb{Z}_N\to\mathbb{Z}_N$可以定义为
$$
dec_K(y)=y^d\mod N
$$
6、对于任意$x,y\in\mathbb{Z}_N$，数对$(e,N)$是RSA的公钥，三元元组$(d,p,q)$是RSA的私钥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/c073bf987d384bd3b8ed67521c8238e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Luj56CB5pS55Y-Y5LiW55WMY3R3,size_20,color_FFFFFF,t_70,g_se,x_16&#34; alt=&#34;05-密码学基础-RSA的介绍_密码学rsa_代码改变世界ctw的博客-CSDN博客&#34;&gt;&lt;/p&gt;
&lt;p&gt;加密函数$enc_K(x)=x^e\mod(N)$，其中N我们不知道该如何分解，并且$gcd(e,\phi(N))=1$，此时这个加密函数叫做&lt;strong&gt;RSA函数&lt;/strong&gt;，又叫做&lt;strong&gt;RSA原语(RSA primitive)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$N$被称为&lt;strong&gt;RSA模数&lt;/strong&gt;，或简称&lt;strong&gt;模&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;素数$p$和$q$被称作&lt;strong&gt;RSA素数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;$e$被称作&lt;strong&gt;公共指数&lt;/strong&gt;或&lt;strong&gt;加密指数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;$d$被称作&lt;strong&gt;私有指数&lt;/strong&gt;或&lt;strong&gt;解密指数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中加密指数和解密指数必须满足以下条件：
$$
ed=1\mod(\phi(N))
$$
即
$$
ed=1+k\phi(N)
$$
其中k为整数。&lt;/p&gt;
&lt;p&gt;这个方程被称为&lt;strong&gt;RSA密钥方程&lt;/strong&gt;，简称&lt;strong&gt;密钥方程&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;122-rsa密码加解密的原理&#34;&gt;1.2.2 RSA密码加解密的原理&lt;/h4&gt;
&lt;p&gt;当明文与模数互素时，解密的正确性是基于欧拉函数。&lt;/p&gt;
&lt;p&gt;我们回顾一下这个定理
$$
a^{\phi(N)}\equiv 1(\bmod N)
$$
其中$a$和$N$互素。&lt;/p&gt;
&lt;p&gt;根据公钥$(e,N)$和明文$m\in\mathbb{Z}_N^*$($i.e.,m\in \mathbb{Z}_N$ and$gcd(m,N)=1)$，可以利用加密方法计算出密文
$$
c=m^e\mod N
$$
根据解密算法和RSA密钥方程，可以计算出明文。&lt;/p&gt;
&lt;p&gt;$$
\begin{equation} \label{eq1}
\begin{split}
c^d\mod N &amp;amp;\equiv(m^e)^d (\bmod N)\
&amp;amp;\equiv m^{ed}(\bmod N)\
&amp;amp;\equiv m^{1+k\phi(N)}(\bmod N)\
&amp;amp;\equiv m(m^{\phi(N)})^k(\bmod N)\
&amp;amp;\equiv m (\bmod N)
\end{split}
\end{equation}
$$
由于$m\in\mathbb{Z}_N$且$c^d\bmod N=m$，当明文与模互素时，我们可以用中国剩余定理很轻易地证得解密方法的正确性。我们要避免明文与模不互素的情况$(i.e.,gcd(m,N)&amp;gt;1)$，因为密文$c=m^e\bmod N$会泄露模数的分解方法，例如，通过计算$gcd(c,N)$可以得到RSA中其中一个素数p或q的值&lt;/p&gt;
&lt;p&gt;在PSA中，我们一开始就将公共指数和私密指数定义为模$\phi(N)$下互逆的两个数，这为将密文解密得到明文提供了足够的（但不一定必要的）前提条件。必要条件是公共指数和私密指数在模&lt;strong&gt;卡米歇尔函数（Carmichael&amp;rsquo;s lambda function)&lt;/strong&gt;$\lambda(N)$的条件下互逆。也就是说，对任意$a$与$N$互质时，存在最小m使得以下式子成立：
$$
a^m\equiv1(\bmod N)
$$
在RSA中，对于模数$N=pq$卡米歇尔函数的值为$\lambda(N)=lcm(p-1,q-1)$。&lt;/p&gt;
&lt;p&gt;根据推导：
$$
\begin{equation}
\begin{split}
\phi(N)&amp;amp;=(p-1)(q-1)\
&amp;amp;=\gcd(p-1,q-1)lcm(p-1,q-1)\
&amp;amp;=\gcd(p-1,q-1)\lambda(N)\
\end{split}
\end{equation}
$$
$\phi(N)$是$\lambda(N)$的倍数。&lt;/p&gt;
&lt;p&gt;这意味着我们在生成密钥时可以使用$\phi(N)$&lt;/p&gt;
&lt;p&gt;在这个过程中，我们可以联想到实际中RSA的公共指数和加密指数有时候定义为模$\lambda(N)$的逆，有时候定义为模$\phi(N)$的逆。&lt;/p&gt;
&lt;p&gt;另外，我们在RSA的例子中只考虑&lt;strong&gt;平衡素数&lt;/strong&gt;的情况，即RSA中的两个素数位数几乎相等。&lt;/p&gt;
&lt;p&gt;对于RSA中$N=pq$，我们可以得到：
$$
4&amp;lt;\frac{1}{2}N^{\frac{1}{2}}&amp;lt;p&amp;lt;N^{\frac{1}{2}}&amp;lt;q&amp;lt;2N^{\frac{1}{2}}
$$
相应的，在RSA的素数平衡时，满足$p&amp;lt;q&amp;lt;2p$
$$
\begin{equation}
\begin{split}
\abs{N-\phi(N)} &amp;amp;=\abs{N-(p-1)(q-1)}\
&amp;amp;=\abs{N-(N-p-q-1)}\
&amp;amp;=\abs{p+q-1}\
&amp;amp;&amp;lt;3N^{\frac{1}{2}}
\end{split}
\end{equation}
$$
因此，模数$N$和欧拉函数$\phi(N)$有几乎$\frac{1}{2}$的重要位数是相同的，结果导致$\phi(N)&amp;lt;N&amp;lt;2\phi(N)$。由于我们在计算中经常用到$N-\phi(N)$这个数值，所以我们用$s$来代替它，也就是说，可以得到：
$$
s=N-\phi(N)=p+q-1&amp;lt;3N^{\frac{1}{2}}
$$&lt;/p&gt;
&lt;p&gt;通过使用不正式的算法来描述公钥密码系统，我们可以定义我们在这个过程中使用的RSA加密算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;密钥生成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个参数n，密钥生成算法包括随机生成两个平衡素数$p$和$q$，他们的乘积$N=pq$即为一个n位的模数。&lt;/li&gt;
&lt;li&gt;选择一个公共加密指数$e$，使得它与$p-1$和$q-1$都互素，然后计算公共加密指数模$\lambda(N)$(或模$\phi(N)$)下的逆作为私密指数d。&lt;/li&gt;
&lt;li&gt;最终这个算法输出了公钥$(e,N)$和私钥$(d,p,q)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个算法可以选择使用更多的参数来确定公共指数和私密指数的大小。在这种情况下，一旦找到了对应的素数，有特定大小的指数可以随机选取，另一个指数可以通过求模$\lambda(N)$($\phi(N)$)下的逆得到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密算法需要输入公钥$(e,N)$和一个明文$m\in\mathbb{Z}_N$&lt;/li&gt;
&lt;li&gt;然后输出密文$c=m^e\bmod N$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解密算法需要输入私钥$(d,p,q)$和一个密文$c\in\mathbb{Z}_N$&lt;/li&gt;
&lt;li&gt;因为对于一些$m\in\mathbb{Z}_N$来说，$c=m^e$，所以输出明文$m=c^d\bmod N$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;密钥生成算法可以轻松地修改，来使它可以满足一些特定的公共指数的需求。当一个公共指数是定值时，例如$e=2^{16}+1$，那么这个随机选取的素数应该满足$\gcd(e,lcm(p-1,q-1))=1$，另一个指数可以通过求模$\lambda(N)$($\phi(N)$)下的逆得到。&lt;/p&gt;
&lt;p&gt;==必须强调的是，我们正在讨论的这个版本的RSA事实上和现实中使用的RSA是不一样的。当RSA被应用时，需要遵守的一个标准是PKCS，同时还会使用随机填充方案。这对于防止攻击和构建一个理论上安全的RSA非常重要==&lt;/p&gt;
&lt;h3 id=&#34;13-rsa的安全性&#34;&gt;1.3 RSA的安全性&lt;/h3&gt;
&lt;p&gt;RSA的安全性取决于解决那些所谓的RSA的问题的难度。&lt;/p&gt;
&lt;p&gt;RSA问题就是提供RSA的公钥$(e,N)$和一个密文$c=m^e\bmod N$，计算出明文$m$。也就是说，计算模$N$的$e$次方根，或者是倒解RSA方程。由于RSA的问题事实上是一个开放性的问题，我们的判断一般都依赖于RSA的一些假设，特别的，我们提出了&lt;strong&gt;RSA假设&lt;/strong&gt;，在这个假设中，要想让RSA问题难以被解决，我们需要使明文$m\in\mathbb{Z}_N$是随机选取的，同时模数是由随机生成的素数构成的足够大的数字。&lt;/p&gt;
&lt;p&gt;自RSA诞生以来，还没有明确的证据证明这个假设是错误的。如果你想知道更多相关的信息，可以去看看&lt;strong&gt;Rivest and Kaliski&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;131-整数因子分解&#34;&gt;1.3.1 整数因子分解&lt;/h4&gt;
&lt;p&gt;另一个经常与RSA的安全性相关联的问题就是著名的整数因子分解问题。简单来说，就是找到给定整数的&lt;strong&gt;非平凡因子&lt;/strong&gt;（除1和自身之外的因子）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要注意的是，如果RSA的模数可以被分解，那么对于任何有效的公共指数e，都可以轻易地计算出私密指数d，因此，我们可以破解出加密所需使用的所有公钥$(e,N)$。也就是说，我们可以轻易的解决RSA中关于用公钥加密的问题，并获得任意可用的明文。因此，解决了整数因子分解的问题后，RSA的问题就不难解决了。&lt;/li&gt;
&lt;li&gt;但是，我们并不知道反过来是不是正确的，也就是说，我们不知道解决RSA的问题能不能有效的帮助解决整数因子分解的问题。有一些证据表明，对于一些特定的公共指数来说，解决RSA问题比解决分解的问题更加容易。但这并不能起到决定性的证明作用。&lt;/li&gt;
&lt;li&gt;这个问题现在正在被Boneh、Venkatesa、Brown、Joux、Naccache、Thome、Aggarwal和Maurer等人研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管RSA的问题被认为比分解的问题更容易解决，在实际中我们假设它们是等同的。RSA的安全级别基于估计下的分解模数的难度。例如，我们可以使用最著名的通用分解算法——&lt;strong&gt;普通数域筛选法（GNFS）&lt;/strong&gt;，这是已知效率最高的分解整数的算法。在这个算法中，我们预计可以通过大约$2^{80}$次操作来分解一个1024位的数字。因此，我们可以认为一个1024位的RSA的安全性和一个80位的一次性密码本（一次一密）的安全性是一样的。目前，我们推荐在非关键加密中使用1024位的模。&lt;/p&gt;
&lt;h4 id=&#34;132-破解rsa&#34;&gt;1.3.2 破解RSA&lt;/h4&gt;
&lt;p&gt;由于整数分解的问题与RSA问题霞凝管，所以我们可以通过分解模数来&lt;strong&gt;破解RSA&lt;/strong&gt;。破解密码系统中有几个概念，同时，这种破解方式和完全破解的概念相符合。如果我们可以分解$N=pq$，我们就可以计算出关于任何公钥$(e,N)$的私钥$(d,p,q)$。因此，我们可以解决任何带有公钥和模数的RSA问题。在第三章和第四章的一些攻击方式只能做到部分破解，也就是说，这种破解方式只能恢复给定的密文中的部分明文，同时，他们也无法做到分解模数。不过，一般来说我们攻击的目的是为了分解给定实例中的RSA的模数&lt;/p&gt;
&lt;p&gt;分解RSA的模数的方法有好几种，其中最显而易见的方法是用一个已知的分解方法去分解这个模数。其他的方法包括计算私密指数$d$或者计算出欧拉函数$\phi(N)$，因为计算这些和分解RSA的模实际上是一样的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们去思考欧拉的$\phi$函数$\phi(N)=(p-1)(q-1)$，当对于RSA的模数N来说$\phi(N)$是已知的时，我们可以通过计算下面的方程来有效的分解模数：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\begin{equation}
\begin{split}
N &amp;amp;=pq\
\phi(N) &amp;amp;=(p-1)(q-1)\
\end{split}
\end{equation}
$$&lt;/p&gt;
&lt;p&gt;​		我们也容易发现$p$和$q$其实就是下面的方程的两个解：&lt;/p&gt;
&lt;p&gt;$$
x^2-(N-\phi(N)+1)x+N=0
$$
​		因此，只要给定了$\phi(N)$，我们就可以有效的分解模数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当已知$\lambda(N)$时，我们同样可以分解模数。根据Simmons，我们可以知道$\gcd(p-1,q-1)$是唯一一个满足下面的式子的数字：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\frac{N}{\lambda(N)}-2 &amp;lt;\gcd(p-1)(q-1)&amp;lt;\frac{N}{\lambda(N)}
$$&lt;/p&gt;
&lt;p&gt;​		因此，当我们得到$\lambda(N)$和$\gcd(p-1,q-1)$时，我们可以简单的计算出：
$$
\phi(N)=\gcd(p-1,q-1)\lambda(p-1,q-1)
$$
​		然后我们继续用上面提到的方法来分解模数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;另一个更加常用的分解模数的方法是：对于一些奇整数$N$，$N=p_1^{v_1}\cdot\cdot\cdot p_r^{v_r}$是他的素数分解方法。我们应当考虑以下三个公式：
$$
\begin{equation}
\begin{split}
\phi(N) &amp;amp;=p_1^{v_1-1}\cdot\cdot\cdot p_r^{v_r-1}(p_1-1)\cdot\cdot\cdot(p_r-1)\
\lambda(N)&amp;amp;=p_1^{v_1-1}\cdot\cdot\cdot p_r^{v_r-1}lcm(p_1-1,\cdot\cdot\cdot, p_r-1)\
\lambda&amp;rsquo;(N)&amp;amp;=lcm(p_1-1,\cdot\cdot\cdot, p_r-1)\
\end{split}
\end{equation}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中$\phi(N)$是欧拉函数，$\lambda(N)$是卡米歇尔函数。我们使用&lt;strong&gt;米勒(Miller)&lt;strong&gt;得出的结论：当我们在多项式时间内可以分解N并且得到一组$\lambda&amp;rsquo;(N)$时，我们可以构建一个&lt;/strong&gt;Las Vegas 算法&lt;/strong&gt;。由于$\phi(N)$和$\lambda(N)$都是$\lambda&amp;rsquo;(N)$的倍数，也就是说只要我们被给定了上述任意一个方程式，我们就可以分解N。因此，知道很多组$\phi(N)$和$\lambda(N)$就能够分解RSA的模数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在我们考虑我们知道私钥的情况。根据密钥方程：
$$
ed=1+k\varphi(N)
$$
其中$\varphi(N)$等于$\phi(N)$或$\lambda(N)$（取决于公共和私密指数是如何定义的），当我们知道d时，我们就可以计算出
$$
ed-1=k\varphi(N)
$$
由于$\varphi(N)$是$\lambda&amp;rsquo;(N)$的倍数，我们可以使用米勒的结论来尝试分解模数。这样，拥有了私密指数，我们就有可能破解RSA&lt;/p&gt;
&lt;p&gt;由于公共指数和私密指数被定义为模$\phi(N)$下互逆，我们知道如果被告知了私密指数$d$，模数肯定会在指数时间内被分解（公共指数和私密指数满足条件$ed&amp;lt;N^2$）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;133-rsa的密码分析&#34;&gt;1.3.3 RSA的密码分析&lt;/h4&gt;
&lt;p&gt;RSA攻击有很多类型，例如，有很多种&lt;strong&gt;侧信道攻击&lt;/strong&gt;的方式，他们利用实现RSA的设备的一些物理性质来进行攻击。其中包括&lt;strong&gt;故障注入（fault injection attacks)&lt;/strong&gt;、&lt;strong&gt;计时攻击(timing attacks)&lt;/strong&gt;、&lt;strong&gt;功耗攻击(power analysis attacks)&lt;/strong&gt;、&lt;strong&gt;分支预测攻击(branch analysis attacks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://cn-sec.com/wp-content/uploads/2022/01/8-1642150089.png&#34; alt=&#34;侧信道攻击与电子数据取证&#34;&gt;&lt;/p&gt;
&lt;p&gt;其他的攻击方式主要关注于密码安全性中的人为干预因素。&lt;strong&gt;社会工程攻击&lt;/strong&gt;可以用来预测一个人的行为。这种方法通过某些方式来获取用户的一些信息。例如，如果你在半夜疯狂的向一个人打电话并告诉他工作上有紧急情况，需要密码短语，你就有可能获取到用于确保RSA私钥的安全性的密码短语。在所谓的**软磨硬泡攻击(rubber-hose attacks)**中，您可以通过武力或者威胁来获取一些信息。&lt;/p&gt;
&lt;p&gt;我们所考虑的攻击方式是排除掉RSA被使用的物理环境的。这些攻击方式是基于RSA密码学的数学结构（模或者密钥方程的形式），并且利用一些特定参数的选择（例如使用较小的公共指数或者私密指数）。我们也会包括一些使用有关私钥的相关知识的攻击方式，但是并不关心这些信息是如何获得的。&lt;/p&gt;
&lt;h4 id=&#34;134-rsa的同态性质&#34;&gt;1.3.4 RSA的同态性质&lt;/h4&gt;
&lt;p&gt;RSA具有乘法的性质——两个明文信息乘积的加密等于两个明文信息加密的乘积（在模N的前提下），这个性质通常被称为&lt;strong&gt;RSA的同态性质&lt;/strong&gt;，并遵循模的乘法的基本性质。利用这个RSA的同态性质，Davida证明了教科书上的RSA面对&lt;strong&gt;选择密文攻击&lt;/strong&gt;是不安全的。如下是Judy Moore对攻击的简化：&lt;/p&gt;
&lt;p&gt;假设对方得到了一个密文$c=m^e \bmod N$并且想要计算出明文$m$，选择一个随机数$x \in \mathbb{Z}_N$，对方索要密文$c_0=cx^e$的明文。由于所需的明文$m_0$满足
$$
m_0=c_0^d \bmod N=(cx^e)^d \bmod N=c^dx^{ed}\bmod N=mx \bmod N
$$
那么对方（已知m0）可以通过简单的计算$m=m_0x^{-1} \bmod N$来获得目标明文。&lt;/p&gt;
&lt;p&gt;另一种使用了RSA的同态性质的攻击方式来自于Bonrh,Joux和Nguyen。他们利用过了这样一个事实：在实际中，RSA通常用于加密一些短信息（通常是用于对称密钥加密系统的一个会话密钥）。本质上，他们的攻击方式是一种&lt;strong&gt;中间相遇攻击(Meet-in-the-middle attack)&lt;/strong&gt;，其中$l$位的目标明文可以被分解为两个$\frac{l}{2}$位的因子$m_1$和$m_2$ $(i.e.,m=m_1m_2)$。首先，这种攻击方式需要共建一个表格，表格里有所有$\frac{l}{2}$位的数字$m_1&amp;rsquo;$和它们的加密结果$(m_1&amp;rsquo;)^e \bmod N$。然后，对于每个可能的$\frac{l}{2}$位的数字$m_2&amp;rsquo;$，计算$c(m_2&amp;rsquo;)^{-e}\bmod N$的值来和表格中的加密结果作比较，当$m_2&amp;rsquo;=m_2$时，满足
$$
c(m_2)^{-e}\bmod N=(m_1m_2)^e(m_2)^{-e}\bmod N=(m_1)^e\bmod N
$$
所以，当找到这种配对方式时，明文$m$的分解方式和他自身就被找到了。这种攻击方式需要计算$2^{\frac{l}{2}+1}$次模幂运算，需要在表格中储存$2^{\frac{l}{2}}l$对数字，并且成功的概率约为18%（超过明文m的选择）&lt;/p&gt;
&lt;p&gt;只要在明文中添加一些结构，这些攻击方式就可以很轻易地被避免，特别是使用适当的填充方案就足够了，例如OAEP。&lt;/p&gt;
&lt;h4 id=&#34;135-语义安全&#34;&gt;1.3.5 语义安全&lt;/h4&gt;
&lt;p&gt;我们回忆一下，一个语义安全的加密系统就是你没有办法从给定的密文（包括已知公钥）中得到任何有关明文的信息。&lt;/p&gt;
&lt;p&gt;我们上面定义的RSA加密系统显然不是一个语义安全的加密系统。尤其是，任何&lt;strong&gt;确定性的加密系统&lt;/strong&gt;都不能说是语义安全的。给定两个明文和其中一个的密文，任何攻击者都可以判断出密文对应的是哪段明文（通过简单的加密明文并进行比较）。因此，所有语义安全的加密系统都应该是&lt;strong&gt;概率性的系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，可以很容易发现，明文的雅克比符号（和模数）可以很轻易地通过密文的雅可比符号（和模数）泄露出来。特别的，我们可以发现对于任意明文$m$和它对应的密文$c$，满足
$$
(\frac{c}{N})=(\frac{m}{N})
$$
因此，仅仅知道密文和公钥，就泄露了一些明文的信息。&lt;/p&gt;
&lt;p&gt;但是，当RSA是通过OAEP实现的时，我们可以证明只要RSA的假设成立，它就是语义安全的。在公钥$e=3$时的情况已经被证实了。所有这些证明都是基于随机语言模型的。我们也可以用其他填充方式来确保RSA安全&lt;/p&gt;
&lt;h3 id=&#34;14-rsa的效率&#34;&gt;1.4 RSA的效率&lt;/h3&gt;
&lt;p&gt;我们简单的考虑一下RSA的效率。特别的，我们考虑素数生成和模幂运算所需要花费的时间，它们分别是密钥生成算法和加密解密算法中最重要的部分。&lt;/p&gt;
&lt;h4 id=&#34;141-素数的生成&#34;&gt;1.4.1 素数的生成&lt;/h4&gt;
&lt;p&gt;RSA中的密钥生成算法需要生成两个大小几乎相同的素数。我们使用Miller-Rabin质数检验和试除法，可以在预计运行时间为$O(\frac{n^4}{\log(n)}+tn^3)$的时间内，生成一个n位的随机（也许）素数。这种方法有最多$t^{-4}$的概率会输出一个复合数，而非素数。这个复杂方法被认为是简单二次运算，可以通过快速乘法来进行改进。但是即使是已知最快的方法，它的复杂度至少也有$O(n^2)$。对于一个大模数来说，这是一个很耗时的操作，尤其是如果需要生成大量素数的情况。&lt;/p&gt;
&lt;p&gt;有很多快速生成素数的方法，但是没有一个能在这方面有显著的突破。&lt;/p&gt;
&lt;h4 id=&#34;142-模幂运算未完&#34;&gt;1.4.2 模幂运算（未完）&lt;/h4&gt;
&lt;p&gt;RSA中的加密和解密都包含模幂运算，当加密指数和模数非常大时，这些操作可能会非常耗时。有一个$b$位的加密指数$B$和一个$n$位的模数$N$，对一些$X \in \mathbb{Z}_N$，有模幂运算
$$
X^B\bmod N
$$
有很多不同的模幂运算算法，但是本质上，这种计算的复杂度可以转化为计算模幂运算的数量。例如，&lt;/p&gt;
&lt;h3 id=&#34;15-rsa签名方案&#34;&gt;1.5 RSA签名方案&lt;/h3&gt;
&lt;p&gt;在RSA被提出时，RSA最初是用于&lt;strong&gt;构造加密方案&lt;/strong&gt;和&lt;strong&gt;数字签名方案&lt;/strong&gt;的。最初，解密操作可以用于为一个文件签名，加密操作可以用于验证签名。在本文中，我们只考虑RSA（及其变种）作为加密方案的情况&lt;/p&gt;
&lt;h3 id=&#34;16-rsa的变种具体见第三章&#34;&gt;1.6 RSA的变种（具体见第三章）&lt;/h3&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;17-一些额外的笔记&#34;&gt;1.7 一些额外的笔记&lt;/h3&gt;
</description>
    </item>
    
  </channel>
</rss>